devtools::document()
devtools::document()
devtools::check()
devtools::check()
devtools::check()
devtools::check()
devtools::check()
devtools::check()
stock_name <- LETTERS
stock <- LETTERS
stock
sample(stock, 10)
sample(stock, 10)
sample(stock, 10)
stock <- LETTERS
l <- list()
for(i in 1:5){
l[[i]] <- sample(stock, 10)
}
protfolio <- data.frame()
stock <- LETTERS
l <- list()
for(i in 1:5){
l[[i]] <- sample(stock, 10)
}
protfolio <- data.frame()
for(i in 1:5){
portfolio[i, ] <- l[[i]]
}
stock <- LETTERS
l <- list()
for(i in 1:5){
l[[i]] <- sample(stock, 10)
}
portfolio <- data.frame()
for(i in 1:5){
portfolio[i, ] <- l[[i]]
}
portfolio
l
portfolio[1, ]
portfolio[1, ] <- l[[1]]
rbind(l[[1]], l[[2]])
stock <- LETTERS
l <- list()
for(i in 1:5){
l[[i]] <- sample(stock, 10)
}
portfolio <- as.data.frame(rbind(l[[1]], l[[2]], l[[3]], l[[4]], l[[5]]))
portfolio
stock <- LETTERS # stock names
l <- list()
for(i in 1:5){
# generate 5 portfolios
l[[i]] <- sample(stock, 10)
}
# portfolio is the data frame with each row containing the 10 core stocks of a portfolio
portfolio <- as.data.frame(rbind(l[[1]], l[[2]], l[[3]], l[[4]], l[[5]]))
library(SA23204171)
convert(portfolio)
stock <- LETTERS # stock names
l <- list()
for(i in 1:5){
# generate 5 portfolios
l[[i]] <- sample(stock, 10)
}
# portfolio is a data frame with each row containing the 10 core stocks of a portfolio.
# portfolio has no error data, because every stock appears at most once in each row.
portfolio <- as.data.frame(rbind(l[[1]], l[[2]], l[[3]], l[[4]], l[[5]]))
library(SA23204171)
result <- convert(portfolio)
result
# stock names
stock <- LETTERS
l <- list()
for(i in 1:10){
# generate 10 portfolios
l[[i]] <- sample(stock, 10)
}
# portfolio is a data frame with each row containing the 10 core stocks of a
# portfolio. portfolio has no error data, because every stock appears at most
# once in each row.
portfolio <- as.data.frame(rbind(l[[1]], l[[2]], l[[3]], l[[4]], l[[5]], l[[6]],
l[[7]], l[[8]], l[[9]], l[[10]]))
library(SA23204171)
result <- convert(portfolio)
result
# stock names
stock <- LETTERS
l <- list()
for(i in 1:10){
# generate 10 portfolios
l[[i]] <- sample(stock, 10)
}
# this portfolio contains false data, with a few stocks appearing more than once
# in the same portfolio
l
# stock names
stock <- LETTERS
l <- list()
for(i in 1:10){
# generate 10 portfolios
l[[i]] <- sample(stock, 10)
}
# this portfolio contains false data, with a few stocks appearing more than once
# in the same portfolio
l[[1]][10] <- l[[1]][5]
l[[6]][8] <- l[[6]][2]
l
# stock names
stock <- LETTERS
l <- list()
for(i in 1:10){
# generate 10 portfolios
l[[i]] <- sample(stock, 10)
}
# this portfolio contains false data, with a few stocks appearing more than once
# in the same portfolio
l[[1]][10] <- l[[1]][5]
l[[6]][8] <- l[[6]][2]
portfolio <- as.data.frame(rbind(l[[1]], l[[2]], l[[3]], l[[4]], l[[5]], l[[6]],
l[[7]], l[[8]], l[[9]], l[[10]]))
# convert the data frame
library(SA23204171)
result <- convert(portfolio)
result
# stock names
stock <- LETTERS
l <- list()
for(i in 1:10){
# generate 10 portfolios
l[[i]] <- sample(stock, 10)
}
# this portfolio contains false data, with a few stocks appearing more than once
# in the same portfolio
l[[1]][10] <- l[[1]][5]
l[[6]][8] <- l[[6]][2]
portfolio <- as.data.frame(rbind(l[[1]], l[[2]], l[[3]], l[[4]], l[[5]], l[[6]],
l[[7]], l[[8]], l[[9]], l[[10]]))
# convert the data frame
library(SA23204171)
result <- convert(portfolio)
result$correct
# stock names
stock <- LETTERS
l <- list()
for(i in 1:10){
# generate 10 portfolios
l[[i]] <- sample(stock, 10)
}
# this portfolio contains false data, with a few stocks appearing more than once
# in the same portfolio
l[[1]][10] <- l[[1]][5]
l[[6]][8] <- l[[6]][2]
portfolio <- as.data.frame(rbind(l[[1]], l[[2]], l[[3]], l[[4]], l[[5]], l[[6]],
l[[7]], l[[8]], l[[9]], l[[10]]))
# convert the data frame
library(SA23204171)
result <- convert(portfolio)
result$correct
# FALSE means there are errors in the original data, so we use correct.error to
# filter out these false portfolios and give the correct converted matrix.
correct.error(result)
# stock names
stock <- LETTERS
l <- list()
for(i in 1:10){
# generate 10 portfolios
l[[i]] <- sample(stock, 10)
}
# this portfolio contains false data, with a few stocks appearing more than once
# in the same portfolio
l[[1]][10] <- l[[1]][5]
l[[6]][8] <- l[[6]][2]
portfolio <- as.data.frame(rbind(l[[1]], l[[2]], l[[3]], l[[4]], l[[5]], l[[6]],
l[[7]], l[[8]], l[[9]], l[[10]]))
# convert the data frame
library(SA23204171)
result <- convert(portfolio)
result$correct
# FALSE means there are errors in the original data, so we use correct.error to
# filter out these false portfolios and give the correct converted matrix.
new_result <- correct.error(result)
new_result
devtools::build_vignettes()
devtools::build_vignettes()
## -----------------------------------------------------------------------------
# stock name
stock <- LETTERS
source("D:/SCHOOL/USTC_master/1st_grade/schoolwork/stat_computing/Packages/SA23204171/doc/intro.R")
devtools::build_vignettes()
devtools::build_vignettes()
devtools::build_vignettes()
devtools::build_vignettes()
devtools::build_vignettes()
devtools::build_vignettes()
devtools::build_vignettes()
devtools::build_vignettes()
devtools::build_vignettes()
devtools::build_vignettes()
devtools::build_vignettes()
devtools::build_vignettes()
devtools::build_vignettes()
# 读取并查看数据
data <- read.csv(file = 'ironslag.csv', header = T)
# 读取并查看数据
data <- read.csv(file = 'ironslag.csv', header = T)
str(data); head(data)
# leave-two-out cross-validation(n/2 fold CV)
n <- nrow(data)
e1 <- e2 <- e3 <- e4 <- numeric(n)
for(k in 1:(n/2)){
y <- data$magnetic[-c(2*k-1, 2*k)]
x <- data$chemical[-c(2*k-1, 2*k)]
J1 <- lm(y~x)
yhat1 <- J1$coef[1] + J1$coef[2] * data$chemical[c(2*k-1, 2*k)]
e1[c(2*k-1, 2*k)] <- data$magnetic[c(2*k-1, 2*k)] - yhat1
J2 <- lm(y~x + I(x^2))
yhat2 <- J2$coef[1] + J2$coef[2] * data$chemical[c(2*k-1, 2*k)] +
J2$coef[3] * data$chemical[c(2*k-1, 2*k)]^2
e2[c(2*k-1, 2*k)] <- data$magnetic[c(2*k-1, 2*k)] - yhat2
J3 <- lm(log(y)~x)
logyhat3 <- J3$coef[1] + J3$coef[2] * data$chemical[c(2*k-1, 2*k)]
yhat3 <- exp(logyhat3)
e3[c(2*k-1, 2*k)] <- data$magnetic[c(2*k-1, 2*k)] - yhat3
J4 <- lm(log(y)~log(x))
logyhat4 <- J4$coef[1] + J4$coef[2] * log(data$chemical[c(2*k-1, 2*k)])
yhat4 <- exp(logyhat4)
e4[c(2*k-1, 2*k)] <- data$magnetic[c(2*k-1, 2*k)] - yhat4
}
c(mean(e1^2), mean(e2^2), mean(e3^2), mean(e4^2))
save('ironslag.rda', compress = T)
data
save(data, file = 'ironslag.rda', compress = T)
# 读取并查看数据
data("ironslag")
attach(ironslag)
# 读取并查看数据
data("ironslag")
attach('ironslag')
# 读取并查看数据
data("ironslag")
attach('ironslag.rda')
# 读取并查看数据
data("ironslag")
attach(data)
# leave-two-out cross-validation(n/2 fold CV)
n <- nrow(data)
e1 <- e2 <- e3 <- e4 <- numeric(n)
for(k in 1:(n/2)){
y <- data$magnetic[-c(2*k-1, 2*k)]
x <- data$chemical[-c(2*k-1, 2*k)]
J1 <- lm(y~x)
yhat1 <- J1$coef[1] + J1$coef[2] * data$chemical[c(2*k-1, 2*k)]
e1[c(2*k-1, 2*k)] <- data$magnetic[c(2*k-1, 2*k)] - yhat1
J2 <- lm(y~x + I(x^2))
yhat2 <- J2$coef[1] + J2$coef[2] * data$chemical[c(2*k-1, 2*k)] +
J2$coef[3] * data$chemical[c(2*k-1, 2*k)]^2
e2[c(2*k-1, 2*k)] <- data$magnetic[c(2*k-1, 2*k)] - yhat2
J3 <- lm(log(y)~x)
logyhat3 <- J3$coef[1] + J3$coef[2] * data$chemical[c(2*k-1, 2*k)]
yhat3 <- exp(logyhat3)
e3[c(2*k-1, 2*k)] <- data$magnetic[c(2*k-1, 2*k)] - yhat3
J4 <- lm(log(y)~log(x))
logyhat4 <- J4$coef[1] + J4$coef[2] * log(data$chemical[c(2*k-1, 2*k)])
yhat4 <- exp(logyhat4)
e4[c(2*k-1, 2*k)] <- data$magnetic[c(2*k-1, 2*k)] - yhat4
}
c(mean(e1^2), mean(e2^2), mean(e3^2), mean(e4^2))
# 导入数据
attach(chickwts)
x <- sort(as.vector(weight[feed == "soybean"]))
y <- sort(as.vector(weight[feed == "linseed"]))
detach(chickwts)
str(x); str(y)
n <- length(x); m <- length(y)
R <- 999                            # number of replicates
z <- c(x, y)                        # pooled sample
reps <- numeric(R)                  # storage for replicates
ecdf <- function(sample, x){
# 经验分布函数
# sample为对应的样本, 为向量
# x为经验分布函数的自变量, 可以为向量
res <- numeric(length(x))
for(i in 1:length(x)){
res[i] <- mean(sample <= x[i])
}
return(res)
}
W_2 <- function(sample1, sample2){
# Cramer-von Mises统计量
n <- length(sample1); m <- length(sample2)
temp1 <- sum((ecdf(sample1, sample1) - ecdf(sample2, sample1))^2)
temp2 <- sum((ecdf(sample1, sample2) - ecdf(sample2, sample2))^2)
return(m*n * (temp1 + temp2)/ (m+n)^2)
}
# Permutation test with Cramer-von Mises statistic
W0 <- W_2(x, y)
for (i in 1:R){
k <- sample(n+m, size = n, replace = F)
x1 <- z[k]
y1 <- z[-k]
reps[i] <- W_2(x1, y1)
}
p <- mean(c(W0, reps) >= W0); p
attach(chickwts)
x <- sort(as.vector(weight[feed == "sunflower"])) # x发生了改变
y <- sort(as.vector(weight[feed == "linseed"]))
detach(chickwts)
str(x); str(y)
n <- length(x); m <- length(y)
R <- 999                            # number of replicates
z <- c(x, y)                        # pooled sample
reps <- numeric(R)                  # storage for replicates
ecdf <- function(sample, x){
# 经验分布函数
# sample为对应的样本, 为向量
# x为经验分布函数的自变量, 可以为向量
res <- numeric(length(x))
for(i in 1:length(x)){
res[i] <- mean(sample <= x[i])
}
return(res)
}
W_2 <- function(sample1, sample2){
# Cramer-von Mises统计量
n <- length(sample1); m <- length(sample2)
temp1 <- sum((ecdf(sample1, sample1) - ecdf(sample2, sample1))^2)
temp2 <- sum((ecdf(sample1, sample2) - ecdf(sample2, sample2))^2)
return(m*n * (temp1 + temp2)/ (m+n)^2)
}
# Permutation test with Cramer-von Mises statistic
W0 <- W_2(x, y)
for (i in 1:R){
k <- sample(n+m, size = n, replace = F)
x1 <- z[k]
y1 <- z[-k]
reps[i] <- W_2(x1, y1)
}
p <- mean(c(W0, reps) >= W0); p
# count five statistic
count5 <- function(x, y){
x1 <- x - mean(x)
y1 <- y - mean(y)
x_extreme <- sum(x1 > max(y1)) + sum(x1 < min(y1))
y_extreme <- sum(y1 > max(x1)) + sum(y1 < min(x1))
return(max(x_extreme, y_extreme))
}
N <- 50       # repeat the test N times
m <- 50; n <- 80
x <- rnorm(m, 0, 1); y <- rnorm(n, 0, 1.5)
D0 <- count5(x, y)
R <- 1000       # number pf replicates
D <- numeric(R) # storage for relicates
p <- numeric(N) # storage for p value in each repeated test
for (i in 1:N){
for (j in 1:R){
k <- sample(m+n, size = m, replace = F)
x1 <- c(x, y)[k]
y1 <- c(x, y)[-k]
D[j] <- count5(x1, y1)
}
p[i] <- mean(c(D0, D) >= D0)
}
round(p, 4)
mean(p < 0.05)
devtools::build_vignettes()
.Last.error
.Last.error.trace
devtools::build_vignettes()
?data()
data
# 读取并查看数据
data(data)
attach(data)
# leave-two-out cross-validation(n/2 fold CV)
n <- nrow(data)
e1 <- e2 <- e3 <- e4 <- numeric(n)
for(k in 1:(n/2)){
y <- data$magnetic[-c(2*k-1, 2*k)]
x <- data$chemical[-c(2*k-1, 2*k)]
J1 <- lm(y~x)
yhat1 <- J1$coef[1] + J1$coef[2] * data$chemical[c(2*k-1, 2*k)]
e1[c(2*k-1, 2*k)] <- data$magnetic[c(2*k-1, 2*k)] - yhat1
J2 <- lm(y~x + I(x^2))
yhat2 <- J2$coef[1] + J2$coef[2] * data$chemical[c(2*k-1, 2*k)] +
J2$coef[3] * data$chemical[c(2*k-1, 2*k)]^2
e2[c(2*k-1, 2*k)] <- data$magnetic[c(2*k-1, 2*k)] - yhat2
J3 <- lm(log(y)~x)
logyhat3 <- J3$coef[1] + J3$coef[2] * data$chemical[c(2*k-1, 2*k)]
yhat3 <- exp(logyhat3)
e3[c(2*k-1, 2*k)] <- data$magnetic[c(2*k-1, 2*k)] - yhat3
J4 <- lm(log(y)~log(x))
logyhat4 <- J4$coef[1] + J4$coef[2] * log(data$chemical[c(2*k-1, 2*k)])
yhat4 <- exp(logyhat4)
e4[c(2*k-1, 2*k)] <- data$magnetic[c(2*k-1, 2*k)] - yhat4
}
c(mean(e1^2), mean(e2^2), mean(e3^2), mean(e4^2))
devtools::build_vignettes()
devtools::build_vignettes()
$stdout
devtools::build_vignettes()
devtools::build_vignettes()
devtools::build_vignettes()
data
ironslag <- data
save(ironslag, file = 'ironslag.rda', compress = T)
devtools::build_vignettes()
ironslag
devtools::build_vignettes()
devtools::build_vignettes()
devtools::build_vignettes()
devtools::build_vignettes()
devtools::build_vignettes()
devtools::build(vignettes=FALSE)
